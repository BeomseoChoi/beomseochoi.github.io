---
layout: post
title: 순환 참조에 대한 걱정
date: 2025-02-26 06:16:00+0900
description: 
tags: formatting links
disqus_comments: true
categories: Develop
---

## 순환 참조

프로그래밍하다보면 두 클래스가 서로를 참조하는 일이 발생하는데 이를 순환 참조라고 부른다. 순환 참조는 안티 패턴으로 잘 알려져 있다. A와 B가 서로를 참조한다고 할 때, A를 해제하기 위해 B를 해제해야 하고, B를 해제하기 위해 A를 해제해야 한다. 이러한 문제를 해결하기 위한 방법론을 마련해야 한다.

참조 관계는 노드 간 연결로 추상화할 수 있다. A가 B에 의존하면 A→B로 표현할 수 있다. 참조 관계를 노드로 표현하면 하나의 자료구조가 된다. 그 자료구조가 그래프이며, cycle이 존재하면 순환 참조가 발생한다. 참조 관계 그래프에서 Cycle을 제거하면 순환 참조 문제를 근본적으로 해결할 수 있다. 참조 관계가 DAG 자료구조가 되도록 클래스를 디자인해야 순환 참조를 막을 수 있다.

근본적인 해결 방법은 알았으나, cycle을 제거하면서 클래스를 디자인하는 게 현실적으로 가능한 작업인가를 고민해야한다. 두 클래스가 통신하는 경우는 매우 빈번하므로 현실적으로 근본적인 해결책은 불가능에 가깝다.

## 소유와 참조

A와 B가 서로 의존할 때, 서로가 의미하는 '의존'이 다를 수 있다. 개념적으로 A는 B를 소유할 수도 있고, 참조할 수도 있다. 두 클래스가 서로의 포인터를 가지기는 하나, 한 클래스는 소유의 의미일 수 있으며, 다른 클래스는 참조의 의미일 수 있다.

이 부분에서 용어를 정리할 필요가 있다. 아래 용어는 널리 쓰이는 표현은 아니고 이 포스트에서 사용할 표현이다.

- 순환 의존
  - A와 B가 서로의 포인터를 가지고 있는 상황  
- 순환 소유
  - A와 B가 소유 목적으로 순환 의존
- 순환 참조
  - A와 B가 참조 목적으로 순환 의존

'널리 알려진' 순환 참조는 순환 의존을 의미한다.

순환 의존은 메모리 해제 이슈를 만든다. 하지만 의존 목적을 생각하면 이 문제를 해결할 수 있다.

- A가 B를 소유하고, B는 A를 참조하는 경우
  - A가 해제되면서 B를 해제한다.
  - B는 A를 참조하고 있지만, 소유하지 않으므로 단순히 참조를 끊으면 된다.
  - 결과적으로, A가 해제되면서 B도 안전하게 해제된다.

하지만 A와 B가 서로를 소유하는 경우가 문제가 된다.

  - A를 해제하면 B도 해제해야 하고, B를 해제하면 다시 A를 해제해야 한다.
  - 결과적으로 A와 B가 서로를 계속 해제하려는 무한 루프에 빠질 수 있으며, 메모리 이중 해제나 메모리 누수 등의 심각한 문제가 발생할 수 있다.

순환 의존은 현실적으로 막을 수 없는 문제지만 순환 소유만은 막아야 한다. 순환 소유는 A와 B를 소유하는 C를 추가하고, A와 B를 순환 참조로 만들면 된다.

```c++

class A;
class B;
class C;

class A
{
    B* b; // 참조
    C* c; // 참조
}

class B
{
    A* a; // 참조
    C* c; // 참조
}

class C
{
    A* a; // 소유
    B* b; // 소유
}
```

가능한 순환 의존(참조-참조, 소유-참조, 소유-소유)을 지금까지 말한 방법으로 해결할 수 있다. 참조는 관계를 끊고, 소유는 해제하며, 서로 소유하면 Mediator를 추가하여 순환 참조로 만든다.

C++은 메모리 해제를 자동으로 관리하기 위한 표준 라이브러리를 제공한다. Shared pointer는 그중 하나이며 reference counting으로 포인터를 관리한다. 그러나 reference counting 또한 순환 의존 문제가 발생한다. Reference count를 가지는 A와 B가 순환 의존하면 서로의 reference count가 1이 되어 둘 다 해제되지 못한다. 그래서 참조 목적 포인터 weak pointer를 제공하여 소유-참조 관계를 만듦으로써 위 문제를 해결할 수 있다.

Reference counting에 대한 내용은 해당 포스트의 목적과 맞지 않아 언급하지 않는다. 또한 shared pointer와 weak pointer의 퍼포먼스 이슈도 언급하지 않는다.

## 결론

순환 의존을 없애는 클래스 디자인은 현실적으로 어렵다. 그리고 순환 의존의 세 가지 케이스는 모두 해결 가능하다. 순환 의존을 최대한 없애되 불가피할 경우 소유와 참조 관계를 생각하며 클래스를 디자인해야 한다.